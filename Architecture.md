Описание архитектуры
====================

В целом приложение соответствует заданию: есть 2 армии
(Великобритании и Франции), армия состоит из отрядов, отряд
-- из юнитов. Юниты трех типов: лучник, конница, мечник.
Помимо военной сущности есть и экономическая, развивающая
военные качества юнитов.

**Порождающие паттерны**

- Юниты -- основа армии.

  `Unit <- AbstractUnit <- Archer, Swordsman, Cavalry`

  `Unit` представляет из себя интерфейс. `AbstractUnit`
содержит реализацию многих общих методов юнитов.
Поскольку юниты двух армий не различаются логически, а
лишь параметрами, для них написаны _**фабрики**_ `UnitFactory <-
EnglishUnitFactory, FrenchUnitFactory`. 

- `PrintManager` -- менеджер, отвечающий за вывод на экран
сообщений из классов бизнес-логики, не взаимодействующими с
пользователем. Код вывода сообщений на экран вынесен в 
отдельный класс, так как не имеет отношения к логике программы,
а также для удобства добавления нового языка (например, русского)
в программу в будущем. Так как такой объект нужен только в
одном экземпляре, в нем реализован паттерн _**синглетон**_.

**Структурные паттерны**

- Иерархия `Армия -- Отряд -- Юнит` имеет древовидную
структуру. Для простоты реализации некоторых методов
(например, для получения общего здоровья армии, отряда или
отдельно взятого юнита) был реализован паттерн
_**компоновщик**_. Классы `Army, Squad, Unit` унаследованы
от абстрактного класса `CombatElement`, содержащего общие
для классов методы.

- По правилам игры-стратегии экономическая деятельность запрещена во время
битв. Интерфейс экономического развития -- `ArmyEconomicsDevelopment`, его
реализация -- `ArmyEconomics`. Для дополнительной защиты игры от нарушения
этого правила реализован паттерн **_защищающего заместителя_** -- 
`ArmyEconomicsProxy`. Он перехватывает все обращения к классу
экономической деятельности и блокирует их, если идет сражение.

- Существует 3 варианта развития армии: увеличить начальное значение
здоровья отдельного отряда, увеличить броню отдельного отряда и сделать
отдельного лучника лучником-магом: тот будет не только наносить урон
сопернику, но и лечить самый отряд с наименьшим здоровьем в армии. Наносить
урон и лечить другой отряд -- это 2 непересекающиеся фичи. Если создавать 
отдельный класс юнита `Лучника-Мага`, придется скопировать код из класса
`Лучника`, чего делать не хочется. А поскольку создавать мага нужно будет
из имеющегося экземпляра класса `Archer` во время игры, лучше всего применить паттерн
**_декоратор_**. `MagicArcherDecorator` перехватывает вызов метода на атаку
и добавляет новый функционал: лечит самый "избитый" отряд. 

**Поведенческие паттерны**

- Армии сражаются следующим образом: в каждую итерацию битвы (они называются
_маневром_) в каждой армии каждый отряд атакует отряд из вражеской армии.
Атакуемый отряд выбирается согласно _**стратегиям**_: атаковать самый 
"здоровый" отряд, атаковать отряд с наименьшим здоровьем или атаковать
случайный отряд. Каждая стратегия реализует паттерн _**команда**_. Такое
решение обосновывается тем, что в будущем нужно будет сохранять историю
прошедшей битвы в память с целью ее восстановления. А для такой цели
идеально подходит паттерн _**команда**_. Стратегии описаны в
`ManeuverCommands.py`.

- Во время битвы внутри бизнес-логики генерируются важные события, о которых
хотелось бы информировать пользователя и, возможно, другие части системы.
Для этого реализован паттерн **_наблюдатель_**. Наблюдатели наследуют
интерфейс `BattleEventsListener` и подписываются на него через
`Army.add_battle_events_subscriber`. Так, например, `PrintManager` 
получает информацию о том, кто кого убил, и выводит это на экран
пользователю.

**Другие классы, не имеющие паттернов**

- Основое взаимодействие с пользователем происходит в `Game`, `ArmyAssembler`,
`PrintManager` и `Battle`. `Game` отвечает за основное меню игры,
`ArmyAssembler` -- заполняет армию юнитами, а `Battle` ведет сражение между
армиями.